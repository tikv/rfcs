# Auth for applications

## Summary

TiKV authentication and authorization can be implemented by leveraging

* token signing
* delegation

PD signs tokens for clients that authenticate.
TiKV and PD verify the tokens.
Clients may delegate their tokens to permit direct TiKV access for users in their own auth system.

This can solve the most pressing auth concerns without attempting to

* push down TiDB's auth into TiKV
* develop a separate RBAC in TIKV


## Motivation

TiKV currently has no concept of authentication.
TiDB supports authentication.
This has been done in the TiDB layer probably in partly because it is a large effort to achieve MySQL compatible auth mechanisms.
However, TiKV exposes its data over a network connection, whereas MySQL storage does not.

This means that any attacker that can connect to a TiKV node can exfiltrate all its data.
This risk can be mitigated by the usage of TiKV's support for mutual TLS authentication.
TLS can identify a client by its certificate, but without auth in TiKV, this just verifies that it came from a trusted CA.
So every connected client is effectively a root user.
There is also risk that the certificate issuance is not properly closed to TiKV clients since we don't actually identify the clients that connect.

TiKV's biggest user is TiDB, and TiDB tooling is now transitioning to operating directly on TiKV (tidb-lightning, br, CDC).
Tooling access is more difficult to secure because its usage can be more dynamic (in addition to some gaps in TLS support).
A database operator would like to be able to allow access for tools in the same way that users are allowed access to TiDB SQL rather than figuring out ad-hoc ways of locking down access.

We want TiKV to be used as a stand-alone project.
This means that TiKV network access to more diverse clients than just PD/TiDB is a requirement.
Essentially every client must implement their own auth just as TiDB has done.
And all these client machines with the ability to access TiKV must be trusted as root users.
Additionally, there is an effort around creating a dashboard.
This effort may perform auth against TiDB, but that means that auth will be unavailable if TiDB is not deployed.



## Detailed design

#### Key Spaces for multiple distinct clients

Auth must be able to work for more than just a single client. To this end, I submitted a [Key Spaces RFC](https://github.com/tikv/rfcs/pull/39).
To avoid coupling with that proposal, this proposal will assume a single TiDB SQL client.
Anywhere in the proposal where a client is mentioned, we can assume the client is a TiDB SQL client or a TiDB SQL related tool operating on the same monolithic key space.
However, in all cases you can substitute the single client for multiple clients operating on distinct key spaces.


#### PD as the authenticator and authorizer

This solution uses the concept of a signed token.
This pattern is becoming more prevalent and these tokens are concretely sometimes a JWT (or a more secure JWT derivative) or a macaroon.
The key pattern is that an identity broker produces a token.
This token can be used with different services without the need for the services to contact the identity broker.
Instead, the service can accept the token as valid if it can decrypt it.
In our case, PD will be the identity broker, and TiKV is the service that the token is sent to.

* PD contains a database of client applications (TiDB SQL). When a client (TiDB SQL) first connects, it must register its authentication information (e.g. password). This information could also potentially be seeded during deployment or by a root user.
* All TiKV clients must first authenticate with PD.
* PD sends back a cryptographically signed token to the client. This means that the token cannot be tampered
* This token may include as metadata the key range of allowed key access and any access restrictions (read-only)
* The client then sends this token with it’s requests to TiKV
* TiKV decrypts the token.
  * Failure: A decryption failure means the token is expired or was tampered with, and the client is denied access.
  * Success: The client is authenticated.
    * TiKV performs authorization by looking at the included metadata to ensure that the client is operating on the keys that it is allowed to. If not, the request is denied.

Hopefully this basic flow is clear. But there are still a lot of implementation details to review.


#### Delegation for tooling

Database interfaces like TiDB that can implement their own auth.
But now we have tools that should be using that auth but need direct TiKV access.

This can be implemented via delegation. A tool would:
* login to TiDB
* request a signed token for accessing TiKV
* TiDB gives a token to the tool that will be recognized by TiKV as delegated by the TiDB user
* The token also includes access restrictions given by TiDB: allowed key range and permissions such as read-only
* This token can then be sent to TIKV just as TiDB itself sends a token

Tools such as backup could benefit from a read-only access restriction.

This proposal does not seek to attempt to push down TiDB auth into the TiKV layer.
Database layers should implement their own auth.
This could cause some difficulties for mapping database access restrictions to TiKV restrictions, but in theory if they know how to store data then they should know how to restrict access.



#### Reducing overhead

Auth will create some additional latency for new requests.
However, I don’t think it needs to create any noticeable overhead for long-lived connections.
TiDB gets a token from PD that can be used for some time period (perhaps 15 minutes).
In the background during that 15 minutes TiDB will renew its token and then switch to the renewed token.
If a long-lived connection can switch to the new token while still connected, then we can avoid disrupting long-lived connections.
Short-lived connections and re-connections can also be optimized In TiKV by caching successfully decrypted tokens.


#### Shared secret and bootstraping

In the above scenario, TiKV must have a mechanism to be able to decrypt the token and ensure it was not tampered with.
One way of doing this is to encrypt it with a secret that only TiKV knows.
At startup, TiKV can get the secret from PD.
However, we must be able to prevent impersonation of a TiKV node, and we can do this with our existing auth mechanism

TiKV itself must also authenticate.
PD must be configured with a TiKV user before it can store data in TiKV.
This user just like any other will require a CA cert or a password.
The user would not have any valid key range or permissions



#### Flushing changes

If the token remains valid to TiKV for 15 minutes, how do we handle making changes to user permissions take effect sooner?
We need a way for early expiration (logout).
To force an immediate logout PD would need to broadcast a token expiration message to TiKV.
I don’t know if PD already does this kind of thing, but messages could be broadcast in a response during normal heartbeat operations.


## Drawbacks

This approach asks more of clients. We will need to ensure that all client libraries implement the auth outlined here.

## Alternatives

#### Just add an authentication policy or client cert white list

The quickest incremental improvement to auth would be to further leverage the existing mutual TLS to deal with the issue of identifying clients.
There is risk that the certificate issuance is not properly closed to TiKV clients since we don't identify the clients that connect.
Declaring who is allowed to authenticate can be known as an "authentication policy".

We can add a white list of allowed client cert subjects (identities).
It is possible that users will only use this to allow a single identity and share that identity among TiKV clients.
This is because all users still have root privilege anyways and it avoids creating new certs and updating the TiKV configuration.

This proposal is intended to work with CA certs as one possible authentication mechanism.
Rather than this minimal version of just specifying allowed client cert identities, we can suggest a minimal version more aligned to this proposal.
That would be to actually specify client applications and their client cert identity in PD.

The biggest downside to these minimal approaches is that all applications still have root privileges (but hopefully without the ability to create new users).
Another downside to these minimal approach is that the deployment configuration or a super user must configure the allowed certs.
Otherwise it is possible to just allow the client application to join and register itself.
Another downside is of course that it requires certs as the only authentication mechanism and corresponding cert management.


#### Don't use a token for TiKV access

We could investigate whether PD can safely propagate its auth information to TiKV and TiKV could perform the auth as well as PD.
This is always going to look like an appealing shortcut, but I think token signing is actually not hard to implement.
A downside of this approach is that it doesn't allow for token delegation.


#### Titan

Titan is Redis implemented on top of TiKV.
It implements signed tokens with namespace restrictions.
This is very similar in spirit to this proposal but implemented in a way that is Redis compatible.
Some information is [available here](https://medium.com/@shafreeck/titan-a-distributed-redis-protocol-compatible-nosql-database-4379a1307661).


#### Etcd

Etcd has [users and roles](https://github.com/etcd-io/etcd/blob/master/Documentation/op-guide/authentication.md#working-with-roles).
Users have passwords and roles give access to a key range.

I consider this the default design of auth for a KV store.
The design here takes some slightly different approaches that I think are better for a KV store designed to be used by applications.
Managing both users and key ranges in such an RBAC key range system would be more difficult for a multi-application database.
The Etcd implementation does have key ranges as first class objects that can be named, whereas key spaces effectively give this.
I also assume that delegation does not exist.

* Etcd requires a root role to create all users. In the TiKV design here, an application can simply claim a key space and setup auth for the keyspace itself.
* The root role must properly manage key ranges to ensure they don’t accidentally overlap
* The root role must manage multiple accessors of the same keys. The design here for TiKV gives ownership to an application and allows it to be in charge of delegating access. If centralization is still desired rather than delegation for some use cases, key spaces still provide a better starting point to ensure that key ranges do not go out of sync and are bounded

The advantage of the etcd implementation is the ability to create roles with fine-grained permissions.


#### FoundationDB

FoundationDB does not implement auth. It is suggested to implement this at the “layer” level (TiDB would be called a SQL layer), with someone even suggesting that auth in a memory unsafe language could be circumvented. They released a document (MongoDB) layer, but it has no auth, and I don’t see auth for their record layer either. We probably can’t know how Apple actually does auth themselves, and it appears likely that the 2-3 other public FoundationDB users may also not be using auth.
FoundationDB is interested in implementing auth, and key range restriction is mentioned here: https://github.com/apple/foundationdb/issues/1419
There is community interest in this feature, with someone [even prototyping an implementation](https://forums.foundationdb.org/t/introducing-the-redis-protocol-fdb-gateway/1320/5)
And other users [ask for the feature](https://forums.foundationdb.org/t/proxy-layer-for-securing-the-cluster/1611/9)

Note that FoundationDB does not have a separate PD. Because we do, the signed token part of the implementation is much more important for us.
FDB does have key spaces via their directory layer. However, the implementation as a client-side layer is problematic because it adds latency (since the key range for the directory alias is actually mutable).



## Unresolved questions

Important details are not detailed in this proposal yet
* the actual authentication mechanisms available
* the token signing mechanisms.

There are some issues we need to think about around root privilige and recovery of lost passwords.
This might extend to including TiKV restarts not requiring passwords.
